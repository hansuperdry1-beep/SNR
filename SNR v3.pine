//@version=6
indicator("SNR", overlay=true, max_lines_count=500, max_labels_count=500)

// ── Inputs ───────────────────────────────────────────────────────────────────
max_lvl    = input.int(200,   "Max Levels",          minval=50,  maxval=500)
extend     = input.int(10,    "Extend",               minval=5,   maxval=50)
req_rej    = input.int(1,     "Required Rejections",  minval=1,   maxval=5)
use_filter = input.bool(false,"Date Filter")
start      = input.time(timestamp("2025-01-01"),       "Start")
end        = input.time(timestamp("2025-01-07 23:59"), "End")
debug_mode = input.bool(false, "Debug Mode",           group="Debug")

// Trade management
sl_pips    = input.int(10,  "Stop Loss (pips)",  minval=1, maxval=500, group="Trade Management")
rr         = input.float(2.0,"Risk:Reward",       minval=0.1, step=0.1, group="Trade Management")
pip_size   = input.float(0.0001, "Pip Size",      minval=0.00001,       group="Trade Management")

// ── Types ─────────────────────────────────────────────────────────────────────
type Level
    line  ln
    label lb
    float price
    int   born
    int   flipped_bar
    int   rej
    int   brk
    bool  isRes
    bool  dead
    bool  confirmed
    bool  pre_rej
    int   rej_count

type Trade
    line  entry_ln
    line  sl_ln
    line  tp_ln
    label dir_lb
    label sl_lb
    label tp_lb
    float entry
    float sl
    float tp
    bool  isLong
    bool  active    // false = pending, true = triggered
    bool  closed
    bool  win

var levels      = array.new<Level>()
var trades      = array.new<Trade>()
var Level tick_preview = na

// Stats
var int   total  = 0
var int   wins   = 0
var int   losses = 0
var float gross_profit = 0.0
var float gross_loss   = 0.0
var float max_dd       = 0.0
var float peak_eq      = 0.0
var float equity       = 0.0
var int   cur_w_streak = 0
var int   cur_l_streak = 0
var int   max_w_streak = 0
var int   max_l_streak = 0

in_range = not use_filter or (time >= start and time <= end)

// ── Helpers ───────────────────────────────────────────────────────────────────
get_color(isRes) => isRes ? color.red : color.green

detect_pattern(c, o, c1, o1) =>
    [(c1 > o1 and c < o) or (c1 < o1 and c < o), (c1 < o1 and c > o) or (c1 > o1 and c > o)]

get_status(lvl) =>
    side     = lvl.isRes ? "RES" : "SUP"
    rej_info = str.tostring(lvl.rej_count) + "/" + str.tostring(req_rej)
    stage    = lvl.confirmed ? "CONFIRMED" : lvl.brk == 1 ? "WAIT_REJ(" + rej_info + ") needs=" + (lvl.isRes ? "BULL" : "BEAR") : lvl.pre_rej ? "PRE_REJ(" + rej_info + ")" : "WAIT_BREAK(" + rej_info + ")"
    str.tostring(lvl.price, "#.#####") + " | " + side + " | " + stage + " | brk=" + str.tostring(lvl.brk)

// ── Level helpers ──────────────────────────────────────────────────────────────
create_level(price, isRes) =>
    col  = debug_mode ? color.new(get_color(isRes), 70) : color.new(color.white, 100)
    styl = debug_mode ? line.style_dashed : line.style_solid
    ln   = line.new(bar_index - 1, price, bar_index + extend, price, color=col, width=1, style=styl)
    lb   = debug_mode ? label.new(bar_index + extend, price, "", style=label.style_label_left, size=size.small, color=color.new(color.navy, 70), textcolor=color.white) : na
    lvl  = Level.new(ln, lb, price, bar_index - 1, -1, 0, 0, isRes, false, false, false, 0)
    if debug_mode and not na(lb)
        label.set_text(lb, get_status(lvl))
    lvl

update_label(lvl) =>
    if debug_mode and not na(lvl.lb)
        label.set_text(lvl.lb, get_status(lvl))
        label.set_x(lvl.lb, bar_index + extend)
        label.set_y(lvl.lb, lvl.price)

delete_level(lvl) =>
    line.delete(lvl.ln)
    if not na(lvl.lb)
        label.delete(lvl.lb)

// ── Trade helpers ──────────────────────────────────────────────────────────────
create_trade(entry, isLong, born_bar) =>
    sl_dist  = sl_pips * pip_size
    tp_dist  = sl_dist * rr
    sl_price = isLong ? entry - sl_dist : entry + sl_dist
    tp_price = isLong ? entry + tp_dist : entry - tp_dist
    col      = isLong ? color.green : color.red
    dir_txt  = isLong ? "Long" : "Short"

    // All lines same color per direction: green = long, red = short
    entry_ln = line.new(born_bar,  entry,    bar_index + extend, entry,    color=col, width=1, style=line.style_dotted)
    sl_ln    = line.new(bar_index, sl_price, bar_index + extend, sl_price, color=col, width=1, style=line.style_dotted)
    tp_ln    = line.new(bar_index, tp_price, bar_index + extend, tp_price, color=col, width=1, style=line.style_dotted)
    dir_lb   = label.new(bar_index + extend, entry,    dir_txt, style=label.style_label_left, size=size.small, color=color.new(color.white, 100), textcolor=col)
    sl_lb    = label.new(bar_index + extend, sl_price, "SL",    style=label.style_label_left, size=size.small, color=color.new(color.white, 100), textcolor=col)
    tp_lb    = label.new(bar_index + extend, tp_price, "TP",    style=label.style_label_left, size=size.small, color=color.new(color.white, 100), textcolor=col)

    Trade.new(entry_ln, sl_ln, tp_ln, dir_lb, sl_lb, tp_lb, entry, sl_price, tp_price, isLong, false, false, false)

delete_trade(t) =>
    line.delete(t.entry_ln)
    line.delete(t.sl_ln)
    line.delete(t.tp_ln)
    label.delete(t.dir_lb)
    label.delete(t.sl_lb)
    label.delete(t.tp_lb)

extend_trade(t) =>
    line.set_x2(t.entry_ln, bar_index + extend)
    line.set_x2(t.sl_ln,    bar_index + extend)
    line.set_x2(t.tp_ln,    bar_index + extend)
    label.set_x(t.dir_lb,   bar_index + extend)
    label.set_x(t.sl_lb,    bar_index + extend)
    label.set_x(t.tp_lb,    bar_index + extend)

activate_trade(t) =>
    // Switch from dotted to solid when entry triggered
    line.set_style(t.entry_ln, line.style_solid)
    line.set_style(t.sl_ln,    line.style_solid)
    line.set_style(t.tp_ln,    line.style_solid)



// ── Bar close: level state ─────────────────────────────────────────────────────
update_level(lvl) =>
    if not lvl.dead
        breaks    = lvl.isRes ? close > lvl.price : close < lvl.price
        touch     = lvl.isRes ? high >= lvl.price : low <= lvl.price
        valid_rej = lvl.isRes ? close > open : close < open
        past_flip = lvl.flipped_bar == -1 or bar_index > lvl.flipped_bar

        if breaks
            if lvl.brk == 0
                lvl.brk         := 1
                lvl.isRes       := not lvl.isRes
                lvl.flipped_bar := bar_index
                lvl.rej_count   := 0
                lvl.confirmed   := lvl.pre_rej ? true : false
            else
                lvl.dead := true
        else
            if not lvl.confirmed and touch and past_flip and valid_rej
                lvl.rej_count += 1
                if lvl.rej_count >= req_rej
                    if lvl.brk == 0
                        lvl.pre_rej   := true
                        lvl.confirmed := true
                    else
                        lvl.confirmed := true

// ── Bar close: trade state handled inline in main block ───────────────────────

// ── Tick: purely visual ────────────────────────────────────────────────────────
tick_visual(lvl) =>
    if not lvl.dead
        breaks    = lvl.isRes ? close > lvl.price : close < lvl.price
        touch     = lvl.isRes ? high >= lvl.price : low <= lvl.price
        valid_rej = lvl.isRes ? close > open : close < open
        past_flip = lvl.flipped_bar == -1 or bar_index > lvl.flipped_bar
        flipped   = not lvl.isRes

        // Production: only show confirmed levels + breakout previews, nothing else
        // Debug: also show dim pending, partial rej progress, final rej preview
        preview_color =
             // ── Debug only: all previews including confirmed ──
             debug_mode and breaks and lvl.brk == 0 and lvl.pre_rej          ? get_color(flipped)
             : debug_mode and breaks and lvl.brk == 0                        ? color.new(color.white, 100)
             : debug_mode and breaks and lvl.brk == 1                        ? color.new(color.gray,  100)
             : debug_mode and not lvl.confirmed and touch and past_flip
               and valid_rej and (lvl.rej_count + 1) >= req_rej              ? get_color(lvl.isRes)
             : debug_mode and not lvl.confirmed and touch and past_flip
               and valid_rej                                                  ? color.new(get_color(lvl.isRes), 50)
             : debug_mode and not lvl.confirmed                               ? color.new(get_color(lvl.isRes), 70)
             : debug_mode and lvl.confirmed                                   ? get_color(lvl.isRes)
             // ── Production: always invisible, trade lines tell the story ──
             :                                                                  color.new(color.white, 100)

        line.set_color(lvl.ln, preview_color)
        line.set_x2(lvl.ln, bar_index + extend)
        if debug_mode
            line.set_style(lvl.ln, lvl.confirmed ? line.style_solid : line.style_dashed)
        update_label(lvl)

// ── Cleanup ────────────────────────────────────────────────────────────────────
cleanup() =>
    if array.size(levels) > 0
        for i = array.size(levels) - 1 to 0
            lvl = array.get(levels, i)
            if lvl.dead
                delete_level(lvl)
                array.remove(levels, i)
    while array.size(levels) > max_lvl
        old = array.shift(levels)
        delete_level(old)

cleanup_trades() =>
    if array.size(trades) > 0
        for i = array.size(trades) - 1 to 0
            t = array.get(trades, i)
            if t.closed
                array.remove(trades, i)

// ── Stats table ────────────────────────────────────────────────────────────────
draw_stats() =>
    var table t = table.new(position.top_right, 2, 7, bgcolor=color.new(color.black, 100), border_width=0)
    wr    = total > 0 ? (wins / total) * 100 : 0.0
    pf    = gross_loss > 0 ? gross_profit / gross_loss : na
    exp   = total > 0 ? ((wins / total) * (sl_pips * rr) - (losses / total) * sl_pips) : 0.0

    table.cell(t, 0, 0, "Total Trades = " + str.tostring(total),                                                         text_color=color.white, text_size=size.small)
    table.cell(t, 0, 1, "W/L = " + str.tostring(wins) + " / " + str.tostring(losses),                                   text_color=color.white, text_size=size.small)
    table.cell(t, 0, 2, "WR = " + str.tostring(wr, "#.##") + "%",                                                        text_color=color.white, text_size=size.small)
    table.cell(t, 0, 3, "PF / Exp = " + (na(pf) ? "N/A" : str.tostring(pf, "#.##")) + " / " + str.tostring(exp, "#.##R"), text_color=color.white, text_size=size.small)
    table.cell(t, 0, 4, "Max DD = " + str.tostring(max_dd, "#.##") + " pips",                                            text_color=color.white, text_size=size.small)
    table.cell(t, 0, 5, "Streaks = W:" + str.tostring(max_w_streak) + " / L:" + str.tostring(max_l_streak),              text_color=color.white, text_size=size.small)

// ── Confirmed bar close ────────────────────────────────────────────────────────
if barstate.isconfirmed
    if not na(tick_preview)
        delete_level(tick_preview)
        tick_preview := na

    if in_range
        [isRes, isSup] = detect_pattern(close, open, close[1], open[1])
        if isRes or isSup
            array.push(levels, create_level(close[1], isRes))

    // Track which levels just got confirmed this bar to spawn trades
    for lvl in levels
        was_confirmed = lvl.confirmed
        update_level(lvl)
        // Spawn pending trade when level becomes confirmed
        if not was_confirmed and lvl.confirmed and not lvl.dead
            array.push(trades, create_trade(lvl.price, not lvl.isRes, lvl.born))

    // Update trade states — iterate by index so closed trades are removed immediately
    if array.size(trades) > 0
        for i = array.size(trades) - 1 to 0
            t = array.get(trades, i)
            if not t.closed
                if not t.active
                    triggered = t.isLong ? low <= t.entry : high >= t.entry
                    if triggered
                        t.active := true
                        activate_trade(t)
                else
                    sl_hit = t.isLong ? low  <= t.sl : high >= t.sl
                    tp_hit = t.isLong ? high >= t.tp : low  <= t.tp
                    if tp_hit or sl_hit
                        total := total + 1
                        if tp_hit
                            wins         := wins + 1
                            gross_profit := gross_profit + (sl_pips * rr)
                            equity       := equity + (sl_pips * rr)
                            cur_w_streak := cur_w_streak + 1
                            cur_l_streak := 0
                            max_w_streak := math.max(max_w_streak, cur_w_streak)
                        else
                            losses       := losses + 1
                            gross_loss   := gross_loss + sl_pips
                            equity       := equity - sl_pips
                            cur_l_streak := cur_l_streak + 1
                            cur_w_streak := 0
                            max_l_streak := math.max(max_l_streak, cur_l_streak)
                        peak_eq := math.max(peak_eq, equity)
                        dd       = peak_eq - equity
                        max_dd  := math.max(max_dd, dd)
                        delete_trade(t)
                        array.remove(trades, i)  // remove immediately

    // Visuals after state settled
    for lvl in levels
        if not lvl.dead
            // Production: confirmed = solid color, unconfirmed = invisible
            // Debug: confirmed = solid, unconfirmed = dashed dim
            col  = lvl.confirmed ? get_color(lvl.isRes) : (debug_mode ? color.new(get_color(lvl.isRes), 70) : color.new(color.white, 100))
            styl = debug_mode ? (lvl.confirmed ? line.style_solid : line.style_dashed) : line.style_solid
            line.set_color(lvl.ln, col)
            line.set_style(lvl.ln, styl)
            update_label(lvl)

    // Extend active/pending trade lines
    for t in trades
        if not t.closed
            extend_trade(t)

    if in_range
        cleanup()
        cleanup_trades()

    draw_stats()

// ── Tick: preview only, zero state mutation ────────────────────────────────────
else
    if in_range
        [isRes_t, isSup_t] = detect_pattern(close, open, close[1], open[1])
        pattern_t = isRes_t or isSup_t
        if pattern_t
            if na(tick_preview)
                tick_preview := create_level(close[1], isRes_t)
            else
                if tick_preview.isRes != isRes_t or tick_preview.price != close[1]
                    delete_level(tick_preview)
                    tick_preview := create_level(close[1], isRes_t)
            line.set_x2(tick_preview.ln, bar_index + extend)
        else
            if not na(tick_preview)
                delete_level(tick_preview)
                tick_preview := na

    for lvl in levels
        tick_visual(lvl)

    // ── Tick: full trade visual update ──────────────────────────────────────────
    // Spawn trade instantly when a level confirms on tick
    for lvl in levels
        if lvl.confirmed and not lvl.dead
            // Check if this level already has a trade
            has_trade = false
            for t in trades
                if t.entry == lvl.price
                    has_trade := true
            if not has_trade
                array.push(trades, create_trade(lvl.price, not lvl.isRes, lvl.born))

    // Update all trade visuals on every tick
    if array.size(trades) > 0
        for i = array.size(trades) - 1 to 0
            t = array.get(trades, i)
            if not t.closed
                extend_trade(t)
                triggered_tick = t.isLong ? low <= t.entry : high >= t.entry
                sl_hit_tick    = t.isLong ? low <= t.sl    : high >= t.sl
                tp_hit_tick    = t.isLong ? high >= t.tp   : low <= t.tp

                if tp_hit_tick or sl_hit_tick
                    // Instant removal on TP/SL hit
                    delete_trade(t)
                    array.remove(trades, i)
                else if triggered_tick or t.active
                    // Active: solid lines
                    line.set_style(t.entry_ln, line.style_solid)
                    line.set_style(t.sl_ln,    line.style_solid)
                    line.set_style(t.tp_ln,    line.style_solid)
                else
                    // Pending: dotted lines
                    line.set_style(t.entry_ln, line.style_dotted)
                    line.set_style(t.sl_ln,    line.style_dotted)
                    line.set_style(t.tp_ln,    line.style_dotted)

    draw_stats()
